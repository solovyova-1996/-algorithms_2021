"""
Задание 1.

Реализуйте свои пользовательские функции, в которых реализуйте:

a) заполнение списка и словаря,
   сделайте замеры и сделайте выводы, что выполняется быстрее и почему
   И укажите сложность каждой ф-ции, которую вы применяете для заполнения.
   У этих ф-ций может быть разная сложность. Поэтому время заполнения списка и словаря может как совпадать, так и отличаться.
b) выполните набор операций и со списком, и со словарем,
   сделайте замеры и сделайте выводы, что и где выполняется быстрее и почему
   И укажите сложность ф-ций, которые вы используете для операций.

Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)

Примечание: eсли вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций
И примените ее к своим функциям!

Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.
"""
import time


# декоратор для замера времени работы функции
def time_seize(func):
    def f(*args):
        start_val = time.time()
        res = func(*args)
        end_val = time.time()
        print(f'Время выполнения функции: {end_val - start_val}')
        return res

    return f


# Возможно я неверно поняла, какие именно пользовательские функции нужно реализовать
@time_seize
# Функция наполнения словаря n-элементами со значением 1
# Сложность функци O(n)
def filling_dict(n):
    dict_test = dict()
    for i in range(n):
        dict_test[i] = 1
    return dict_test


@time_seize
# Функция наполнения словаря с использованием fromkeys
# Сложность функци O(n)
def filling_dict_1(n):
    dict_test = dict()
    i = 0
    dict_test.fromkeys([n for i in range(n)], 1)
    return dict_test


@time_seize
# Функция наполнения списка с помощью append
# Сложность функци O(n)
def filling_list(n):
    list_test = list()
    for i in range(n):
        list_test.append(i)
    return list_test


@time_seize
# Функция наполнения списка с помощью генератора списка
# Сложность функци O(n)
def filling_list_1(n):
    return [n for i in range(n)]


filling_dict_test = filling_dict(100000)
# Время выполнения функции: 0.031258344650268555
filling_dict_1_test = filling_dict_1(100000)
# Время выполнения функции: 0.0156252384185791
filling_list_test = filling_list(100000)
# Время выполнения функции: 0.01563262939453125
filling_list_1_test = filling_list_1(100000)
# Время выполнения функции: 0.015627622604370117

# вывод: при реализации функций с линейной сложностью для наполнения списка и словаря
# время наполнения словаря приблизительно вдвое выше,чем наполнения списка,так как под словарь выделяется
# больше памяти


# Замер времи получения элемента из словаря по ключу O(1)
@time_seize
def get_item(storage, idx):
    return storage[idx]


k = 1000
get_item(filling_dict_test, k)
# Время выполнения функции: 0.0

# Замер времи получения элемента из списка по индексу O(n)
@time_seize
def get_item(storage, idx):
    return storage[idx]


idx = 1000
get_item(filling_list_1_test, idx)
# Время выполнения функции: 0.0

# Вывод: получение элемента из словаря и списка имеет константную сложность

# Вставка элемента в словарь O(1)
@time_seize
def insert_item(storage, key, item):
    storage[key] = item


insert_item(filling_dict_test, 'key', '133')
# Время выполнения функции: 0.0

# Вставка элемента в список по индексу
@time_seize
def insert_el_in_lst(lst, el, idx):
    # функция insert имеет линейную сложность O(n)
    return lst.insert(idx, el)


insert_el_in_lst(filling_list_test, '0', 100000)
# Время выполнения функции: 0.0

# вывод: вставка элемента в словарь имеет константную сложность O(1),а вставка
# элемента в список с использованием insert линейную, вставка элемента в словарь будет выполняться быстрее

# удаление элемента из словаря и списка при помощи pop()
# для словаря сложность O(1),для списка O(n)
@time_seize
def del_item(storage,idx):
    return storage.pop(idx)

# удаление элемента из словаря
del_item(filling_dict_test,6999)
# Время выполнения функции: 0.0
# удаление элемента из списка
del_item(filling_list_test,6999)
# Время выполнения функции: 0.0
# думаю замер времени показывает 0.0 так как операции не достаточно сложные и выполняются быстро

# вывод: для словаря характерно бастрая вставка, получение и удаление элементов,
# но словари занимают больше памяти чем списки
# те же опреации для списков,в теории,будут происходить медленее, так как имеют линейную сложность